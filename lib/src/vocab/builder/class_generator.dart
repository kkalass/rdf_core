// Copyright (c) 2025, Klas Kalaß <habbatical@gmail.com>
// All rights reserved. Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

import 'model/vocabulary_model.dart';

/// Generator for creating Dart classes from vocabulary models.
///
/// This class is responsible for generating well-formatted Dart code
/// representing a vocabulary, with proper class structure, documentation,
/// and type safety.
class VocabularyClassGenerator {
  /// Creates a new vocabulary class generator.
  const VocabularyClassGenerator();

  /// Generates Dart code for a vocabulary model.
  String generate(VocabularyModel model) {
    final buffer = StringBuffer();

    // Add header and copyright
    _writeHeader(buffer);

    // Write library documentation and declaration first
    _writeLibraryDoc(buffer, model);

    // Import necessary packages (after library declaration)
    _writeImports(buffer);

    // Write primary class containing all terms
    _writePrimaryClass(buffer, model);

    // Write individual class for each RDF class
    _writeIndividualClasses(buffer, model);

    return buffer.toString();
  }

  /// Writes the file header with copyright information.
  void _writeHeader(StringBuffer buffer) {
    buffer.writeln('// Copyright (c) 2025, Klas Kalaß <habbatical@gmail.com>');
    buffer.writeln(
      '// All rights reserved. Use of this source code is governed by a BSD-style',
    );
    buffer.writeln('// license that can be found in the LICENSE file.');
    buffer.writeln();
    buffer.writeln('// GENERATED CODE - DO NOT MODIFY BY HAND');
    buffer.writeln('// Generated by VocabularyBuilder');
    buffer.writeln();
  }

  /// Writes the required imports for the generated file.
  void _writeImports(StringBuffer buffer) {
    buffer.writeln("import 'package:rdf_core/src/graph/rdf_term.dart';");
    buffer.writeln();
  }

  /// Writes the library documentation.
  void _writeLibraryDoc(StringBuffer buffer, VocabularyModel model) {
    final name = _capitalize(model.name);

    buffer.writeln('/// $name Vocabulary');
    buffer.writeln('///');
    buffer.writeln(
      '/// Provides constants for the ${name.toUpperCase()} vocabulary',
    );
    buffer.writeln('/// (${model.namespace}).');
    buffer.writeln('///');
    buffer.writeln('/// Example usage:');
    buffer.writeln('/// ```dart');
    buffer.writeln('/// import \'package:rdf_core/vocab.dart\';');

    if (model.properties.isNotEmpty) {
      final exampleProp = _dartIdentifier(model.properties.first.localName);
      buffer.writeln(
        '/// final property = ${name}.$exampleProp; // Access property directly from main class',
      );
    }

    if (model.classes.isNotEmpty) {
      final exampleClass = _dartIdentifier(model.classes.first.localName);
      buffer.writeln(
        '/// final type = ${name}$exampleClass.type; // Access class type',
      );

      if (model.properties.isNotEmpty) {
        final exampleProp = _dartIdentifier(model.properties.first.localName);
        buffer.writeln(
          '/// final property = ${name}$exampleClass.$exampleProp; // Access property from class',
        );
      }
    }

    buffer.writeln('/// ```');
    buffer.writeln('///');
    buffer.writeln(
      '/// All constants are pre-constructed as IriTerm objects to enable direct use in',
    );
    buffer.writeln(
      '/// constructing RDF graphs without repeated string concatenation or term creation.',
    );
    buffer.writeln('///');
    buffer.writeln('/// [Vocabulary Reference](${model.namespace})');
    buffer.writeln('library ${model.prefix}_vocab;');
    buffer.writeln();
  }

  /// Writes the primary vocabulary class that contains all terms.
  void _writePrimaryClass(StringBuffer buffer, VocabularyModel model) {
    final className = _capitalize(model.name);

    buffer.writeln(
      '/// Main ${className} vocabulary class containing all terms',
    );
    buffer.writeln('///');
    buffer.writeln(
      '/// Contains all terms defined in the ${model.namespace} vocabulary.',
    );
    buffer.writeln('class $className {');
    buffer.writeln('  // Private constructor prevents instantiation');
    buffer.writeln('  const ${className}._();');
    buffer.writeln();
    buffer.writeln('  /// Base IRI for ${className} vocabulary');
    buffer.writeln('  /// [Spec](${model.namespace})');
    buffer.writeln("  static const String namespace = '${model.namespace}';");
    buffer.writeln("  static const String prefix = '${model.prefix}';");
    buffer.writeln();

    // Add all terms
    for (final term in [
      ...model.classes,
      ...model.datatypes,
      ...model.otherTerms,
    ]) {
      _writeTerm(buffer, term, className);
    }

    // Add predicates
    for (final property in model.properties) {
      _writeTerm(buffer, property, className);
    }

    buffer.writeln('}');
    buffer.writeln();
  }

  /// Writes a class for each RDF class in the vocabulary.
  void _writeIndividualClasses(StringBuffer buffer, VocabularyModel model) {
    if (model.classes.isEmpty) return;

    final className = _capitalize(model.name);

    // Build class hierarchy for property inheritance
    final classHierarchy = _buildClassHierarchy(model);

    // Map of property IRIs to property objects
    final propertyMap = {for (final prop in model.properties) prop.iri: prop};

    // Generate a class for each RDF class
    for (final rdfClass in model.classes) {
      final dartClassName = '$className${_dartIdentifier(rdfClass.localName)}';

      buffer.writeln(
        '/// ${rdfClass.localName} class from ${className} vocabulary',
      );
      buffer.writeln('///');

      if (rdfClass.comment != null) {
        final formattedComment = _formatMultilineComment(rdfClass.comment!);
        buffer.writeln('/// $formattedComment');
        buffer.writeln('///');
      }

      buffer.writeln(
        '/// This class provides access to all properties that can be used with ${rdfClass.localName}.',
      );
      buffer.writeln('/// [Class Reference](${rdfClass.iri})');

      buffer.writeln('class $dartClassName {');
      buffer.writeln('  // Private constructor prevents instantiation');
      buffer.writeln('  const ${dartClassName}._();');
      buffer.writeln();

      // Add the type field
      buffer.writeln('  /// IRI term for the ${rdfClass.localName} class');
      buffer.writeln(
        '  /// Use this to specify that a resource is of this type.',
      );
      buffer.writeln(
        "  static const type = IriTerm.prevalidated('${rdfClass.iri}');",
      );
      buffer.writeln();

      // Get all properties that can be used with this class
      final properties = _getPropertiesForClass(
        rdfClass.iri,
        classHierarchy,
        propertyMap,
      );

      // Write all applicable properties
      for (final property in properties) {
        _writeTerm(buffer, property, className, prefix: '  ');
      }

      buffer.writeln('}');
      buffer.writeln();
    }
  }

  /// Writes a single term as a static constant.
  void _writeTerm(
    StringBuffer buffer,
    VocabularyTerm term,
    String className, {
    String prefix = '',
  }) {
    final dartName = _dartIdentifier(term.localName);

    // Write documentation
    buffer.writeln(
      '$prefix/// IRI for ${className.toLowerCase()}:${term.localName}',
    );
    buffer.writeln('$prefix///');

    if (term.comment != null) {
      // Format the comment for Dart documentation
      final formattedComment = _formatMultilineComment(term.comment!);
      buffer.writeln('$prefix/// $formattedComment');
      buffer.writeln('$prefix///');
    }

    // Add domain and range information for properties
    if (term is VocabularyProperty) {
      if (term.domains.isNotEmpty) {
        buffer.writeln('$prefix/// Domain: ${term.domains.join(', ')}');
      }

      if (term.ranges.isNotEmpty) {
        buffer.writeln('$prefix/// Range: ${term.ranges.join(', ')}');
      }

      if (term.domains.isNotEmpty || term.ranges.isNotEmpty) {
        buffer.writeln('$prefix///');
      }
    }

    // Write the constant declaration with correct indentation
    // Korrektur: Entferne das Leerzeichen zwischen Präfix und "static const"
    buffer.writeln(
      "${prefix}static const $dartName = IriTerm.prevalidated('${term.iri}');",
    );
    buffer.writeln();
  }

  /// Formats a multiline comment for Dart documentation
  String _formatMultilineComment(String comment) {
    return comment
        .split('\n')
        .map((line) => line.trim())
        .where((line) => line.isNotEmpty)
        .join('\n  /// ');
  }

  /// Builds a map of class IRI to list of all parent class IRIs (including inherited)
  Map<String, Set<String>> _buildClassHierarchy(VocabularyModel model) {
    final hierarchy = <String, Set<String>>{};

    // Initialize with direct parent classes
    for (final rdfClass in model.classes) {
      hierarchy[rdfClass.iri] = Set.from(rdfClass.superClasses);
    }

    // Resolve full inheritance (transitive closure)
    bool changed;
    do {
      changed = false;

      for (final entry in hierarchy.entries) {
        final classIri = entry.key;
        final parents = Set<String>.from(entry.value);

        for (final parentIri in parents.toList()) {
          // Add parent's parents
          if (hierarchy.containsKey(parentIri)) {
            final grandparents = hierarchy[parentIri]!;
            final sizeBefore = parents.length;
            parents.addAll(grandparents);
            if (parents.length > sizeBefore) {
              changed = true;
              hierarchy[classIri] = parents;
            }
          }
        }
      }
    } while (changed);

    return hierarchy;
  }

  /// Gets all properties applicable to a given class including inherited properties
  List<VocabularyProperty> _getPropertiesForClass(
    String classIri,
    Map<String, Set<String>> classHierarchy,
    Map<String, VocabularyProperty> propertyMap,
  ) {
    final result = <VocabularyProperty>[];
    final allParentClasses = {classIri, ...(classHierarchy[classIri] ?? {})};

    for (final property in propertyMap.values) {
      // If property has no domains, it can be used with any class
      if (property.domains.isEmpty) {
        result.add(property);
        continue;
      }

      // Check if any domain of the property is compatible with this class
      for (final domain in property.domains) {
        if (allParentClasses.contains(domain)) {
          result.add(property);
          break;
        }
      }
    }

    return result;
  }

  /// Converts a local name to a valid Dart identifier.
  String _dartIdentifier(String localName) {
    // Special case handling for names that would result in invalid Dart identifiers
    if (localName.startsWith('_')) {
      return 'underscore${localName.substring(1)}';
    }

    if (localName.startsWith(RegExp(r'\d'))) {
      return 'n$localName';
    }

    // Replace characters that are not valid in Dart identifiers
    return localName.replaceAll(RegExp(r'[^a-zA-Z0-9_]'), '_');
  }

  /// Capitalizes the first letter of a string.
  String _capitalize(String s) {
    if (s.isEmpty) return s;
    return s[0].toUpperCase() + s.substring(1);
  }
}
