// Copyright (c) 2025, Klas Kalaß <habbatical@gmail.com>
// All rights reserved. Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

import 'dart:async';
import 'package:build/build.dart';
import 'package:logging/logging.dart';
import '../manifest.dart';
import '../../../rdf_core.dart';
import 'class_generator.dart';
import 'model/vocabulary_model.dart';

/// Logger for the vocabulary builder
final log = Logger('rdf.vocab.builder');

/// A builder that generates Dart classes for RDF vocabularies.
///
/// This builder uses the vocabulary manifest to fetch vocabulary definitions,
/// parse them using the existing RDF parser infrastructure, and generate
/// corresponding Dart classes with IriTerm constants.
class VocabularyBuilder implements Builder {
  /// Creates a new vocabulary builder.
  ///
  /// The builder will process all vocabularies defined in the vocabulary manifest.
  const VocabularyBuilder();

  @override
  Map<String, List<String>> get buildExtensions => {
        // Input -> Output mappings
        r'$lib$': [
          'src/vocab/generated/_index.dart',
          for (final name in vocabularyManifest.keys)
            'src/vocab/generated/$name.dart',
        ],
      };

  @override
  Future<void> build(BuildStep buildStep) async {
    log.info('Starting vocabulary generation');
    
    final futures = <Future<void>>[];
    
    // Process each vocabulary
    for (final entry in vocabularyManifest.entries) {
      final name = entry.key;
      final source = entry.value;
      
      futures.add(_processVocabulary(buildStep, name, source));
    }
    
    // Wait for all vocabulary processing to complete
    await Future.wait(futures);
    
    // Generate the index file
    await _generateIndex(buildStep);
    
    log.info('Vocabulary generation completed');
  }

  /// Processes a single vocabulary and generates its Dart class.
  Future<void> _processVocabulary(
    BuildStep buildStep,
    String name,
    VocabularySource source,
  ) async {
    try {
      log.info('Processing vocabulary: $name from ${source.namespace}');
      
      // Load vocabulary content
      final content = await source.loadContent();
      
      // Create RDF core instance with standard formats
      final rdfCore = RdfCore.withStandardFormats();
      
      // Parse the vocabulary using the appropriate format
      final format = source.getFormat();
      final graph = rdfCore.parse(content, contentType: _getContentTypeForFormat(format));
      
      // Extract vocabulary model from parsed graph
      final model = VocabularyModelExtractor.extractFrom(
        graph, 
        source.namespace,
        name,
      );
      
      // Generate the Dart class
      final generator = VocabularyClassGenerator();
      final dartCode = generator.generate(model);
      
      // Write the generated code to a file
      final outputId = AssetId(
        buildStep.inputId.package,
        'lib/src/vocab/generated/$name.dart',
      );
      
      await buildStep.writeAsString(outputId, dartCode);
      
      log.info('Generated vocabulary class: $name');
    } catch (e, stackTrace) {
      log.severe('Error processing vocabulary $name: $e\n$stackTrace');
    }
  }
  
  /// Maps format names to content types
  String _getContentTypeForFormat(String format) {
    switch (format.toLowerCase()) {
      case 'turtle':
        return 'text/turtle';
      case 'rdf/xml':
      case 'xml':
        return 'application/rdf+xml';
      case 'json-ld':
        return 'application/ld+json';
      case 'n-triples':
        return 'application/n-triples';
      default:
        return 'text/turtle'; // Default to Turtle
    }
  }

  /// Generates an index file that exports all generated vocabulary classes.
  Future<void> _generateIndex(BuildStep buildStep) async {
    final buffer = StringBuffer()
      ..writeln('// Copyright (c) 2025, Klas Kalaß <habbatical@gmail.com>')
      ..writeln('// All rights reserved. Use of this source code is governed by a BSD-style')
      ..writeln('// license that can be found in the LICENSE file.')
      ..writeln()
      ..writeln('// GENERATED CODE - DO NOT MODIFY BY HAND')
      ..writeln('// Generated by VocabularyBuilder')
      ..writeln();
    
    // Export all generated vocabulary files
    for (final name in vocabularyManifest.keys) {
      buffer.writeln("export '$name.dart';");
    }
    
    final outputId = AssetId(
      buildStep.inputId.package,
      'lib/src/vocab/generated/_index.dart',
    );
    
    await buildStep.writeAsString(outputId, buffer.toString());
    
    log.info('Generated vocabulary index file');
  }
}

/// Creates a vocabulary builder with the given options.
Builder vocabularyBuilder(BuilderOptions options) => const VocabularyBuilder();