// Copyright (c) 2025, Klas Kalaß <habbatical@gmail.com>
// All rights reserved. Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

import 'model/vocabulary_model.dart';

/// Generator for creating Dart classes from vocabulary models.
///
/// This class is responsible for generating well-formatted Dart code
/// representing a vocabulary, with proper class structure, documentation,
/// and type safety.
class VocabularyClassGenerator {
  /// Creates a new vocabulary class generator.
  const VocabularyClassGenerator();

  /// Generates Dart code for a vocabulary model.
  String generate(VocabularyModel model) {
    final buffer = StringBuffer();

    // Add header and copyright
    _writeHeader(buffer);

    // Import necessary packages
    _writeImports(buffer);

    // Write library documentation
    _writeLibraryDoc(buffer, model);

    // Write primary (deprecated) class
    _writePrimaryClass(buffer, model);

    // Write types class
    _writeTypesClass(buffer, model);

    // Write predicates class
    _writePredicatesClass(buffer, model);

    return buffer.toString();
  }

  /// Writes the file header with copyright information.
  void _writeHeader(StringBuffer buffer) {
    buffer.writeln('// Copyright (c) 2025, Klas Kalaß <habbatical@gmail.com>');
    buffer.writeln(
      '// All rights reserved. Use of this source code is governed by a BSD-style',
    );
    buffer.writeln('// license that can be found in the LICENSE file.');
    buffer.writeln();
    buffer.writeln('// GENERATED CODE - DO NOT MODIFY BY HAND');
    buffer.writeln('// Generated by VocabularyBuilder');
    buffer.writeln();
  }

  /// Writes the required imports for the generated file.
  void _writeImports(StringBuffer buffer) {
    buffer.writeln("import 'package:rdf_core/src/graph/rdf_term.dart';");
    buffer.writeln();
  }

  /// Writes the library documentation.
  void _writeLibraryDoc(StringBuffer buffer, VocabularyModel model) {
    final name = _capitalize(model.name);

    buffer.writeln('/// $name Vocabulary');
    buffer.writeln('///');
    buffer.writeln(
      '/// Provides constants for the ${name.toUpperCase()} vocabulary',
    );
    buffer.writeln('/// (${model.namespace}).');
    buffer.writeln('///');
    buffer.writeln('/// Example usage:');
    buffer.writeln('/// ```dart');
    buffer.writeln('/// import \'package:rdf_core/vocab.dart\';');

    if (model.properties.isNotEmpty) {
      final exampleProp = _dartIdentifier(model.properties.first.localName);
      buffer.writeln('/// final property = ${name}Predicates.$exampleProp;');
    }

    if (model.classes.isNotEmpty) {
      final exampleClass = _dartIdentifier(model.classes.first.localName);
      buffer.writeln('/// final type = ${name}Types.$exampleClass;');
    }

    buffer.writeln('/// ```');
    buffer.writeln('///');
    buffer.writeln(
      '/// All constants are pre-constructed as IriTerm objects to enable direct use in',
    );
    buffer.writeln(
      '/// constructing RDF graphs without repeated string concatenation or term creation.',
    );
    buffer.writeln('///');
    buffer.writeln('/// [Vocabulary Reference](${model.namespace})');
    buffer.writeln('library ${model.prefix}_vocab;');
    buffer.writeln();
  }

  /// Writes the primary vocabulary class.
  void _writePrimaryClass(StringBuffer buffer, VocabularyModel model) {
    final className = _capitalize(model.name);

    buffer.writeln('/// Base ${className} namespace and utility functions');
    buffer.writeln('@deprecated');
    buffer.writeln('class $className {');
    buffer.writeln('  // coverage:ignore-start');
    buffer.writeln('  const ${className}._();');
    buffer.writeln('  // coverage:ignore-end');
    buffer.writeln();
    buffer.writeln('  /// Base IRI for ${className} vocabulary');
    buffer.writeln('  /// [Spec](${model.namespace})');
    buffer.writeln("  static const String namespace = '${model.namespace}';");
    buffer.writeln("  static const String prefix = '${model.prefix}';");
    buffer.writeln();

    // Add all terms
    for (final term in [
      ...model.classes,
      ...model.datatypes,
      ...model.otherTerms,
    ]) {
      _writeTerm(buffer, term, className);
    }

    // Add predicates
    for (final property in model.properties) {
      _writeTerm(buffer, property, className);
    }

    buffer.writeln('}');
    buffer.writeln();
  }

  /// Writes the types class with class and datatype terms.
  void _writeTypesClass(StringBuffer buffer, VocabularyModel model) {
    if (model.classes.isEmpty && model.datatypes.isEmpty) {
      return; // Skip if there are no types
    }

    final className = _capitalize(model.name);

    buffer.writeln('/// ${className} type/class constants.');
    buffer.writeln('///');
    buffer.writeln(
      '/// Contains IRIs that represent classes or types defined in the ${className} vocabulary.',
    );
    buffer.writeln('@deprecated');
    buffer.writeln('class ${className}Types {');
    buffer.writeln('  // coverage:ignore-start');
    buffer.writeln('  const ${className}Types._();');
    buffer.writeln('  // coverage:ignore-end');
    buffer.writeln();

    // Add class and datatype terms
    for (final clazz in model.classes) {
      _writeTerm(buffer, clazz, className);
    }

    for (final datatype in model.datatypes) {
      _writeTerm(buffer, datatype, className);
    }

    buffer.writeln('}');
    buffer.writeln();
  }

  /// Writes the predicates class with property terms.
  void _writePredicatesClass(StringBuffer buffer, VocabularyModel model) {
    if (model.properties.isEmpty) {
      return; // Skip if there are no predicates
    }

    final className = _capitalize(model.name);

    buffer.writeln('/// ${className} predicate constants.');
    buffer.writeln('///');
    buffer.writeln(
      '/// Contains IRIs for properties defined in the ${className} vocabulary.',
    );
    buffer.writeln('@deprecated');
    buffer.writeln('class ${className}Predicates {');
    buffer.writeln('  // coverage:ignore-start');
    buffer.writeln('  const ${className}Predicates._();');
    buffer.writeln('  // coverage:ignore-end');
    buffer.writeln();

    // Add property terms
    for (final property in model.properties) {
      _writeTerm(buffer, property, className);
    }

    buffer.writeln('}');
    buffer.writeln();
  }

  /// Writes a single term as a static constant.
  void _writeTerm(StringBuffer buffer, VocabularyTerm term, String className) {
    final dartName = _dartIdentifier(term.localName);

    // Write documentation
    buffer.writeln(
      '  /// IRI for ${className.toLowerCase()}:${term.localName}',
    );
    buffer.writeln('  ///');

    if (term.comment != null) {
      // Format the comment for Dart documentation
      final formattedComment = term.comment!
          .split('\n')
          .map((line) => line.trim())
          .where((line) => line.isNotEmpty)
          .join('\n  /// ');

      buffer.writeln('  /// $formattedComment');
      buffer.writeln('  ///');
    }

    // Add domain and range information for properties
    if (term is VocabularyProperty) {
      if (term.domains.isNotEmpty) {
        buffer.writeln('  /// Domain: ${term.domains.join(', ')}');
      }

      if (term.ranges.isNotEmpty) {
        buffer.writeln('  /// Range: ${term.ranges.join(', ')}');
      }

      if (term.domains.isNotEmpty || term.ranges.isNotEmpty) {
        buffer.writeln('  ///');
      }
    }

    // Write the constant declaration
    buffer.writeln(
      "  static const $dartName = IriTerm.prevalidated('\${${className}.namespace}${term.localName}');",
    );
    buffer.writeln();
  }

  /// Converts a local name to a valid Dart identifier.
  String _dartIdentifier(String localName) {
    // Special case handling for names that would result in invalid Dart identifiers
    if (localName.startsWith('_')) {
      return 'underscore${localName.substring(1)}';
    }

    if (localName.startsWith(RegExp(r'\d'))) {
      return 'n$localName';
    }

    // Replace characters that are not valid in Dart identifiers
    return localName.replaceAll(RegExp(r'[^a-zA-Z0-9_]'), '_');
  }

  /// Capitalizes the first letter of a string.
  String _capitalize(String s) {
    if (s.isEmpty) return s;
    return s[0].toUpperCase() + s.substring(1);
  }
}
